!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.coffeelint=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
CoffeeLint is freely distributable under the MIT license.
 */
var ASTLinter, CoffeeScript, ERROR, ErrorReport, IGNORE, LexicalLinter, LineLinter, RULES, WARN, _rules, cache, coffeelint, defaults, difference, extend, hasSyntaxError, mergeDefaultConfig, nodeRequire, packageJSON, sameJSON,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

coffeelint = exports;

nodeRequire = require;

if (typeof window !== "undefined" && window !== null) {
  CoffeeScript = window.CoffeeScript;
}

if (CoffeeScript == null) {
  CoffeeScript = nodeRequire('coffee-script');
}

if (CoffeeScript == null) {
  throw new Error('Unable to find CoffeeScript');
}

packageJSON = require('./../package.json');

coffeelint.VERSION = packageJSON.version;

ERROR = 'error';

WARN = 'warn';

IGNORE = 'ignore';

coffeelint.RULES = RULES = require('./rules.coffee');

extend = function() {
  var destination, k, len, n, source, sources, v;
  destination = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  for (n = 0, len = sources.length; n < len; n++) {
    source = sources[n];
    for (k in source) {
      v = source[k];
      destination[k] = v;
    }
  }
  return destination;
};

defaults = function(source, defaults) {
  return extend({}, defaults, source);
};

difference = function(a, b) {
  var j, ref, results;
  j = 0;
  results = [];
  while (j < a.length) {
    if (ref = a[j], indexOf.call(b, ref) >= 0) {
      results.push(a.splice(j, 1));
    } else {
      results.push(j++);
    }
  }
  return results;
};

LineLinter = require('./line_linter.coffee');

LexicalLinter = require('./lexical_linter.coffee');

ASTLinter = require('./ast_linter.coffee');

cache = null;

mergeDefaultConfig = function(userConfig) {
  var config, rule, ruleConfig, ruleLoader;
  try {
    ruleLoader = nodeRequire('./ruleLoader');
    ruleLoader.loadFromConfig(coffeelint, userConfig);
  } catch (undefined) {}
  config = {};
  if (userConfig.coffeelint) {
    config.coffeelint = userConfig.coffeelint;
  }
  for (rule in RULES) {
    ruleConfig = RULES[rule];
    config[rule] = defaults(userConfig[rule], ruleConfig);
  }
  return config;
};

sameJSON = function(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
};

coffeelint.trimConfig = function(userConfig) {
  var config, dConfig, dValue, key, newConfig, ref, rule, value;
  newConfig = {};
  userConfig = mergeDefaultConfig(userConfig);
  for (rule in userConfig) {
    config = userConfig[rule];
    dConfig = RULES[rule];
    if (rule === 'coffeelint') {
      config.transforms = config._transforms;
      delete config._transforms;
      config.coffeescript = config._coffeescript;
      delete config._coffeescript;
      newConfig[rule] = config;
    } else if ((config.level === (ref = dConfig.level) && ref === 'ignore')) {
      void 0;
    } else if (config.level === 'ignore') {
      newConfig[rule] = {
        level: 'ignore'
      };
    } else {
      config.module = config._module;
      delete config._module;
      for (key in config) {
        value = config[key];
        if (key === 'message' || key === 'description' || key === 'name') {
          continue;
        }
        dValue = dConfig[key];
        if (value !== dValue && !sameJSON(value, dValue)) {
          if (newConfig[rule] == null) {
            newConfig[rule] = {};
          }
          newConfig[rule][key] = value;
        }
      }
    }
  }
  return newConfig;
};

coffeelint.invertLiterate = function(source) {
  var len, line, n, newSource, ref;
  source = CoffeeScript.helpers.invertLiterate(source);
  newSource = "";
  ref = source.split("\n");
  for (n = 0, len = ref.length; n < len; n++) {
    line = ref[n];
    if (line.match(/^#/)) {
      line = line.replace(/\s*$/, '');
    }
    line = line.replace(/^\s{4}/g, '');
    newSource += line + "\n";
  }
  return newSource;
};

_rules = {};

coffeelint.registerRule = function(RuleConstructor, ruleName) {
  var e, name, p, ref, ref1;
  if (ruleName == null) {
    ruleName = void 0;
  }
  p = new RuleConstructor;
  name = (p != null ? (ref = p.rule) != null ? ref.name : void 0 : void 0) || "(unknown)";
  e = function(msg) {
    throw new Error("Invalid rule: " + name + " " + msg);
  };
  if (p.rule == null) {
    e("Rules must provide rule attribute with a default configuration.");
  }
  if (p.rule.name == null) {
    e("Rule defaults require a name");
  }
  if ((ruleName != null) && ruleName !== p.rule.name) {
    e("Mismatched rule name: " + ruleName);
  }
  if (p.rule.message == null) {
    e("Rule defaults require a message");
  }
  if (p.rule.description == null) {
    e("Rule defaults require a description");
  }
  if ((ref1 = p.rule.level) !== 'ignore' && ref1 !== 'warn' && ref1 !== 'error') {
    e("Default level must be 'ignore', 'warn', or 'error'");
  }
  if (typeof p.lintToken === 'function') {
    if (!p.tokens) {
      e("'tokens' is required for 'lintToken'");
    }
  } else if (typeof p.lintLine !== 'function' && typeof p.lintAST !== 'function') {
    e("Rules must implement lintToken, lintLine, or lintAST");
  }
  RULES[p.rule.name] = p.rule;
  return _rules[p.rule.name] = RuleConstructor;
};

coffeelint.getRules = function() {
  var key, len, n, output, ref;
  output = {};
  ref = Object.keys(RULES).sort();
  for (n = 0, len = ref.length; n < len; n++) {
    key = ref[n];
    output[key] = RULES[key];
  }
  return output;
};

coffeelint.registerRule(require('./rules/arrow_spacing.coffee'));

coffeelint.registerRule(require('./rules/braces_spacing.coffee'));

coffeelint.registerRule(require('./rules/no_tabs.coffee'));

coffeelint.registerRule(require('./rules/no_trailing_whitespace.coffee'));

coffeelint.registerRule(require('./rules/max_line_length.coffee'));

coffeelint.registerRule(require('./rules/line_endings.coffee'));

coffeelint.registerRule(require('./rules/no_trailing_semicolons.coffee'));

coffeelint.registerRule(require('./rules/indentation.coffee'));

coffeelint.registerRule(require('./rules/camel_case_classes.coffee'));

coffeelint.registerRule(require('./rules/colon_assignment_spacing.coffee'));

coffeelint.registerRule(require('./rules/no_implicit_braces.coffee'));

coffeelint.registerRule(require('./rules/no_nested_string_interpolation.coffee'));

coffeelint.registerRule(require('./rules/no_plusplus.coffee'));

coffeelint.registerRule(require('./rules/no_throwing_strings.coffee'));

coffeelint.registerRule(require('./rules/no_backticks.coffee'));

coffeelint.registerRule(require('./rules/no_implicit_parens.coffee'));

coffeelint.registerRule(require('./rules/no_empty_param_list.coffee'));

coffeelint.registerRule(require('./rules/no_stand_alone_at.coffee'));

coffeelint.registerRule(require('./rules/space_operators.coffee'));

coffeelint.registerRule(require('./rules/duplicate_key.coffee'));

coffeelint.registerRule(require('./rules/empty_constructor_needs_parens.coffee'));

coffeelint.registerRule(require('./rules/cyclomatic_complexity.coffee'));

coffeelint.registerRule(require('./rules/newlines_after_classes.coffee'));

coffeelint.registerRule(require('./rules/no_unnecessary_fat_arrows.coffee'));

coffeelint.registerRule(require('./rules/missing_fat_arrows.coffee'));

coffeelint.registerRule(require('./rules/non_empty_constructor_needs_parens.coffee'));

coffeelint.registerRule(require('./rules/no_unnecessary_double_quotes.coffee'));

coffeelint.registerRule(require('./rules/no_debugger.coffee'));

coffeelint.registerRule(require('./rules/no_interpolation_in_single_quotes.coffee'));

coffeelint.registerRule(require('./rules/no_empty_functions.coffee'));

coffeelint.registerRule(require('./rules/prefer_english_operator.coffee'));

coffeelint.registerRule(require('./rules/spacing_after_comma.coffee'));

coffeelint.registerRule(require('./rules/transform_messes_up_line_numbers.coffee'));

coffeelint.registerRule(require('./rules/ensure_comprehensions.coffee'));

coffeelint.registerRule(require('./rules/no_this.coffee'));

coffeelint.registerRule(require('./rules/eol_last.coffee'));

coffeelint.registerRule(require('./rules/no_private_function_fat_arrows.coffee'));

hasSyntaxError = function(source) {
  try {
    CoffeeScript.tokens(source);
    return false;
  } catch (undefined) {}
  return true;
};

ErrorReport = require('./error_report.coffee');

coffeelint.getErrorReport = function() {
  return new ErrorReport(coffeelint);
};

coffeelint.lint = function(source, userConfig, literate) {
  var all_errors, astErrors, block_config, cmd, config, disabled, disabled_initially, e, errors, i, l, len, len1, len2, lexErrors, lexicalLinter, lineErrors, lineLinter, m, n, name, next_line, o, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ruleLoader, rules, s, sourceLength, t, tokensByLine, transform;
  if (userConfig == null) {
    userConfig = {};
  }
  if (literate == null) {
    literate = false;
  }
  errors = [];
  if (cache != null) {
    cache.setConfig(userConfig);
  }
  if (cache != null ? cache.has(source) : void 0) {
    return cache != null ? cache.get(source) : void 0;
  }
  config = mergeDefaultConfig(userConfig);
  if (literate) {
    source = this.invertLiterate(source);
  }
  if ((userConfig != null ? (ref = userConfig.coffeelint) != null ? ref.transforms : void 0 : void 0) != null) {
    sourceLength = source.split("\n").length;
    ref2 = userConfig != null ? (ref1 = userConfig.coffeelint) != null ? ref1.transforms : void 0 : void 0;
    for (n = 0, len = ref2.length; n < len; n++) {
      m = ref2[n];
      try {
        ruleLoader = nodeRequire('./ruleLoader');
        transform = ruleLoader.require(m);
        source = transform(source);
      } catch (undefined) {}
    }
    if (sourceLength !== source.split("\n").length && config.transform_messes_up_line_numbers.level !== 'ignore') {
      errors.push(extend({
        lineNumber: 1,
        context: "File was transformed from " + sourceLength + " lines to " + (source.split("\n").length) + " lines"
      }, config.transform_messes_up_line_numbers));
    }
  }
  if ((userConfig != null ? (ref3 = userConfig.coffeelint) != null ? ref3.coffeescript : void 0 : void 0) != null) {
    CoffeeScript = ruleLoader.require(userConfig.coffeelint.coffeescript);
  }
  for (name in userConfig) {
    if (name !== 'coffeescript_error' && name !== '_comment') {
      if (_rules[name] == null) {
        void 0;
      }
    }
  }
  disabled_initially = [];
  ref4 = source.split('\n');
  for (o = 0, len1 = ref4.length; o < len1; o++) {
    l = ref4[o];
    s = LineLinter.configStatement.exec(l);
    if ((s != null ? s.length : void 0) > 2 && indexOf.call(s, 'enable') >= 0) {
      ref5 = s.slice(1);
      for (q = 0, len2 = ref5.length; q < len2; q++) {
        r = ref5[q];
        if (r !== 'enable' && r !== 'disable') {
          if (!(r in config && ((ref6 = config[r].level) === 'warn' || ref6 === 'error'))) {
            disabled_initially.push(r);
            config[r] = {
              level: 'error'
            };
          }
        }
      }
    }
  }
  astErrors = new ASTLinter(source, config, _rules, CoffeeScript).lint();
  errors = errors.concat(astErrors);
  if (!hasSyntaxError(source)) {
    lexicalLinter = new LexicalLinter(source, config, _rules, CoffeeScript);
    lexErrors = lexicalLinter.lint();
    errors = errors.concat(lexErrors);
    tokensByLine = lexicalLinter.tokensByLine;
    lineLinter = new LineLinter(source, config, _rules, tokensByLine, literate);
    lineErrors = lineLinter.lint();
    errors = errors.concat(lineErrors);
    block_config = lineLinter.block_config;
  } else {
    block_config = {
      enable: {},
      disable: {}
    };
  }
  errors.sort(function(a, b) {
    return a.lineNumber - b.lineNumber;
  });
  all_errors = errors;
  errors = [];
  disabled = disabled_initially;
  next_line = 0;
  for (i = t = 0, ref7 = source.split('\n').length; 0 <= ref7 ? t < ref7 : t > ref7; i = 0 <= ref7 ? ++t : --t) {
    for (cmd in block_config) {
      rules = block_config[cmd][i];
      if (rules != null) {
        ({
          'disable': function() {
            return disabled = disabled.concat(rules);
          },
          'enable': function() {
            difference(disabled, rules);
            if (rules.length === 0) {
              return disabled = disabled_initially;
            }
          }
        })[cmd]();
      }
    }
    while (next_line === i && all_errors.length > 0) {
      next_line = all_errors[0].lineNumber - 1;
      e = all_errors[0];
      if (e.lineNumber === i + 1 || (e.lineNumber == null)) {
        e = all_errors.shift();
        if (ref8 = e.rule, indexOf.call(disabled, ref8) < 0) {
          errors.push(e);
        }
      }
    }
  }
  if (cache != null) {
    cache.set(source, errors);
  }
  return errors;
};

coffeelint.setCache = function(obj) {
  return cache = obj;
};



},{"./../package.json":2,"./ast_linter.coffee":3,"./error_report.coffee":5,"./lexical_linter.coffee":6,"./line_linter.coffee":7,"./rules.coffee":8,"./rules/arrow_spacing.coffee":9,"./rules/braces_spacing.coffee":10,"./rules/camel_case_classes.coffee":11,"./rules/colon_assignment_spacing.coffee":12,"./rules/cyclomatic_complexity.coffee":13,"./rules/duplicate_key.coffee":14,"./rules/empty_constructor_needs_parens.coffee":15,"./rules/ensure_comprehensions.coffee":16,"./rules/eol_last.coffee":17,"./rules/indentation.coffee":18,"./rules/line_endings.coffee":19,"./rules/max_line_length.coffee":20,"./rules/missing_fat_arrows.coffee":21,"./rules/newlines_after_classes.coffee":22,"./rules/no_backticks.coffee":23,"./rules/no_debugger.coffee":24,"./rules/no_empty_functions.coffee":25,"./rules/no_empty_param_list.coffee":26,"./rules/no_implicit_braces.coffee":27,"./rules/no_implicit_parens.coffee":28,"./rules/no_interpolation_in_single_quotes.coffee":29,"./rules/no_nested_string_interpolation.coffee":30,"./rules/no_plusplus.coffee":31,"./rules/no_private_function_fat_arrows.coffee":32,"./rules/no_stand_alone_at.coffee":33,"./rules/no_tabs.coffee":34,"./rules/no_this.coffee":35,"./rules/no_throwing_strings.coffee":36,"./rules/no_trailing_semicolons.coffee":37,"./rules/no_trailing_whitespace.coffee":38,"./rules/no_unnecessary_double_quotes.coffee":39,"./rules/no_unnecessary_fat_arrows.coffee":40,"./rules/non_empty_constructor_needs_parens.coffee":41,"./rules/prefer_english_operator.coffee":42,"./rules/space_operators.coffee":43,"./rules/spacing_after_comma.coffee":44,"./rules/transform_messes_up_line_numbers.coffee":45}],2:[function(require,module,exports){
module.exports={
  "name": "coffeelint",
  "description": "Lint your CoffeeScript",
  "version": "1.12.1",
  "homepage": "http://www.coffeelint.org",
  "keywords": [
    "lint",
    "coffeescript",
    "coffee-script"
  ],
  "author": "Matthew Perpick <clutchski@gmail.com>",
  "main": "./lib/coffeelint.js",
  "engines": {
    "npm": ">=1.3.7",
    "node": ">=0.8.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/clutchski/coffeelint.git"
  },
  "bin": {
    "coffeelint": "./bin/coffeelint"
  },
  "dependencies": {
    "coffee-script": "^1.9.1",
    "glob": "^4.0.0",
    "ignore": "^2.2.15",
    "optimist": "^0.6.1",
    "resolve": "^0.6.3",
    "strip-json-comments": "^1.0.2"
  },
  "devDependencies": {
    "vows": ">=0.6.0",
    "underscore": ">=1.4.4"
  },
  "license": "MIT",
  "scripts": {
    "pretest": "cake compile",
    "test": "./vowsrunner.js --spec test/*.coffee test/*.litcoffee",
    "testrule": "npm run compile && ./vowsrunner.js --spec",
    "posttest": "npm run lint",
    "prepublish": "cake prepublish",
    "publish": "cake publish",
    "lint": "cake compile && ./bin/coffeelint .",
    "lint-csv": "cake compile && ./bin/coffeelint --csv .",
    "lint-jslint": "cake compile && ./bin/coffeelint --jslint .",
    "compile": "cake compile"
  }
}
},{}],3:[function(require,module,exports){
var ASTApi, ASTLinter, BaseLinter, hasChildren, node_children,
  hasProp = {}.hasOwnProperty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseLinter = require('./base_linter.coffee');

node_children = {
  Class: ['variable', 'parent', 'body'],
  Code: ['params', 'body'],
  For: ['body', 'source', 'guard', 'step'],
  If: ['condition', 'body', 'elseBody'],
  Obj: ['properties'],
  Op: ['first', 'second'],
  Switch: ['subject', 'cases', 'otherwise'],
  Try: ['attempt', 'recovery', 'ensure'],
  Value: ['base', 'properties'],
  While: ['condition', 'guard', 'body']
};

hasChildren = function(node, children) {
  var ref;
  return (node != null ? (ref = node.children) != null ? ref.length : void 0 : void 0) === children.length && (node != null ? node.children.every(function(elem, i) {
    return elem === children[i];
  }) : void 0);
};

ASTApi = (function() {
  function ASTApi(config1) {
    this.config = config1;
  }

  ASTApi.prototype.getNodeName = function(node) {
    var children, name, ref;
    name = node != null ? (ref = node.constructor) != null ? ref.name : void 0 : void 0;
    if (node_children[name]) {
      return name;
    } else {
      for (name in node_children) {
        if (!hasProp.call(node_children, name)) continue;
        children = node_children[name];
        if (hasChildren(node, children)) {
          return name;
        }
      }
    }
  };

  return ASTApi;

})();

module.exports = ASTLinter = (function(superClass) {
  extend(ASTLinter, superClass);

  function ASTLinter(source, config, rules, CoffeeScript) {
    this.CoffeeScript = CoffeeScript;
    ASTLinter.__super__.constructor.call(this, source, config, rules);
    this.astApi = new ASTApi(this.config);
  }

  ASTLinter.prototype.acceptRule = function(rule) {
    return typeof rule.lintAST === 'function';
  };

  ASTLinter.prototype.lint = function() {
    var coffeeError, err, error, errors, j, len, ref, rule, v;
    errors = [];
    try {
      this.node = this.CoffeeScript.nodes(this.source);
    } catch (error) {
      coffeeError = error;
      err = this._parseCoffeeScriptError(coffeeError);
      if (err != null) {
        errors.push(err);
      }
      return errors;
    }
    ref = this.rules;
    for (j = 0, len = ref.length; j < len; j++) {
      rule = ref[j];
      this.astApi.createError = (function(_this) {
        return function(attrs) {
          if (attrs == null) {
            attrs = {};
          }
          return _this.createError(rule.rule.name, attrs);
        };
      })(this);
      rule.errors = errors;
      v = this.normalizeResult(rule, rule.lintAST(this.node, this.astApi));
      if (v != null) {
        return v;
      }
    }
    return errors;
  };

  ASTLinter.prototype._parseCoffeeScriptError = function(coffeeError) {
    var attrs, lineNumber, match, message, rule;
    rule = this.config['coffeescript_error'];
    message = coffeeError.toString();
    lineNumber = -1;
    if (coffeeError.location != null) {
      lineNumber = coffeeError.location.first_line + 1;
    } else {
      match = /line (\d+)/.exec(message);
      if ((match != null ? match.length : void 0) > 1) {
        lineNumber = parseInt(match[1], 10);
      }
    }
    attrs = {
      message: message,
      level: rule.level,
      lineNumber: lineNumber
    };
    return this.createError('coffeescript_error', attrs);
  };

  return ASTLinter;

})(BaseLinter);



},{"./base_linter.coffee":4}],4:[function(require,module,exports){
var BaseLinter, defaults, extend,
  slice = [].slice;

extend = function() {
  var destination, i, k, len, source, sources, v;
  destination = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  for (i = 0, len = sources.length; i < len; i++) {
    source = sources[i];
    for (k in source) {
      v = source[k];
      destination[k] = v;
    }
  }
  return destination;
};

defaults = function(source, defaults) {
 